<!DOCTYPE html><html lang="en"><head><title>bn</title></head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0"><meta name="groc-relative-root" content=""><meta name="groc-document-path" content="bn"><meta name="groc-project-path" content="lib/bn.js"><meta name="groc-github-url" content="https://github.com/ryanxcharles/fullnode"><link rel="stylesheet" type="text/css" media="all" href="assets/style.css"><script type="text/javascript" src="assets/behavior.js"></script><body><div id="meta"><div class="file-path"><a href="https://github.com/ryanxcharles/fullnode/blob/master/lib/bn.js">lib/bn.js</a></div></div><div id="document"><div class="segment"><div class="comments "><div class="wrapper"><h1 id="big-number">Big Number</h1>
<p>Ah, big numbers. One of the elements of cryptography. Since javascript
numbers are only precise up to about 53 bits, and bitcoin is based on
cryptography that uses 256 bit numbers, we must use a big number library.
The library we use at the moment is Fedor Indutny&#39;s bn.js library. Since big
numbers are extremely useful, we provide some very basic wrappers for his
big number class and expose it. The wrappers merely allow you to do, say,
bn.cmp(num) instead of just bn.cmp(bn), which is nice. The primary way to
use this is bn(str) (where str is base 10) or bn(num) or
bn().fromBuffer(buf) or bn().fromSM(buf). You can also do little endian,
which bitcoin likes a lot, with bn().fromBuffer(buf, {endian: &#39;little&#39;}) or
bn().fromSM(buf, {endian: &#39;little&#39;}).</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">var</span> _BN = <span class="hljs-built_in">require</span>(<span class="hljs-string">'bn.js'</span>);

<span class="hljs-keyword">var</span> BN = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">BN</span><span class="hljs-params">(n, base)</span> {</span>
  <span class="hljs-keyword">if</span> (!(<span class="hljs-keyword">this</span> <span class="hljs-keyword">instanceof</span> BN)) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> BN(n, base);
  }
  _BN.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
};

BN.prototype = _BN.prototype;

<span class="hljs-keyword">var</span> reversebuf = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(buf)</span> {</span>
  <span class="hljs-keyword">var</span> buf2 = <span class="hljs-keyword">new</span> Buffer(buf.length);
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; buf.length; i++) {
    buf2[i] = buf[buf.length-<span class="hljs-number">1</span>-i];
  }
  <span class="hljs-keyword">return</span> buf2;
};

BN.prototype.toJSON = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.toString();
};

BN.prototype.fromJSON = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(str)</span> {</span>
  <span class="hljs-keyword">var</span> bn = BN(str);
  bn.copy(<span class="hljs-keyword">this</span>);
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
};

BN.prototype.fromNumber = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(n)</span> {</span>
  <span class="hljs-keyword">var</span> bn = BN(n);
  bn.copy(<span class="hljs-keyword">this</span>);
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
};

BN.prototype.toNumber = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">parseInt</span>(<span class="hljs-keyword">this</span>[<span class="hljs-string">'toString'</span>](<span class="hljs-number">10</span>), <span class="hljs-number">10</span>);
};

BN.prototype.fromString = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(str)</span> {</span>
  <span class="hljs-keyword">var</span> bn = BN(str);
  bn.copy(<span class="hljs-keyword">this</span>);
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
};

BN.fromBuffer = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(buf, opts)</span> {</span>
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> opts !== <span class="hljs-string">'undefined'</span> &amp;&amp; opts.endian === <span class="hljs-string">'little'</span>) {
    buf = reversebuf(buf);
  }
  <span class="hljs-keyword">var</span> hex = buf.toString(<span class="hljs-string">'hex'</span>);
  <span class="hljs-keyword">var</span> bn = <span class="hljs-keyword">new</span> BN(hex, <span class="hljs-number">16</span>);
  <span class="hljs-keyword">return</span> bn;
};

BN.prototype.fromBuffer = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(buf, opts)</span> {</span>
  <span class="hljs-keyword">var</span> bn = BN.fromBuffer(buf, opts);
  bn.copy(<span class="hljs-keyword">this</span>);

  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
};

BN.prototype.toBuffer = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(opts)</span> {</span>
  <span class="hljs-keyword">var</span> buf;
  <span class="hljs-keyword">if</span> (opts &amp;&amp; opts.size) {
    <span class="hljs-keyword">var</span> hex = <span class="hljs-keyword">this</span>.toString(<span class="hljs-number">16</span>, <span class="hljs-number">2</span>);
    <span class="hljs-keyword">var</span> natlen = hex.length/<span class="hljs-number">2</span>;
    buf = <span class="hljs-keyword">new</span> Buffer(hex, <span class="hljs-string">'hex'</span>);

    <span class="hljs-keyword">if</span> (natlen == opts.size)
      buf = buf;

    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (natlen &gt; opts.size) {
      buf = buf.slice(natlen - buf.length, buf.length);
    }

    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (natlen &lt; opts.size) {
      <span class="hljs-keyword">var</span> rbuf = <span class="hljs-keyword">new</span> Buffer(opts.size);
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; buf.length; i++)
        rbuf[rbuf.length-<span class="hljs-number">1</span>-i] = buf[buf.length-<span class="hljs-number">1</span>-i];
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; opts.size - natlen; i++)
        rbuf[i] = <span class="hljs-number">0</span>;
      buf = rbuf;
    }
  }
  <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">var</span> hex = <span class="hljs-keyword">this</span>.toString(<span class="hljs-number">16</span>, <span class="hljs-number">2</span>);
    buf = <span class="hljs-keyword">new</span> Buffer(hex, <span class="hljs-string">'hex'</span>);
  }

  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> opts !== <span class="hljs-string">'undefined'</span> &amp;&amp; opts.endian === <span class="hljs-string">'little'</span>) {
    buf = reversebuf(buf);
  }

  <span class="hljs-keyword">return</span> buf;
};</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Signed magnitude buffer. Most significant bit represents sign (0 = positive,
1 = negative).</p></div></div><div class="code"><div class="wrapper">BN.prototype.fromSM = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(buf, opts)</span> {</span>
  <span class="hljs-keyword">if</span> (buf.length === <span class="hljs-number">0</span>)
    <span class="hljs-keyword">this</span>.fromBuffer(<span class="hljs-keyword">new</span> Buffer([<span class="hljs-number">0</span>]));

  <span class="hljs-keyword">var</span> endian = <span class="hljs-string">'big'</span>;
  <span class="hljs-keyword">if</span> (opts)
    endian = opts.endian;

  <span class="hljs-keyword">if</span> (endian == <span class="hljs-string">'little'</span>)
    buf = reversebuf(buf);

  <span class="hljs-keyword">if</span> (buf[<span class="hljs-number">0</span>] &amp; <span class="hljs-number">0x80</span>) {
    buf[<span class="hljs-number">0</span>] = buf[<span class="hljs-number">0</span>] &amp; <span class="hljs-number">0x7f</span>;
    <span class="hljs-keyword">this</span>.fromBuffer(buf);
    <span class="hljs-keyword">this</span>.neg().copy(<span class="hljs-keyword">this</span>);
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">this</span>.fromBuffer(buf);
  }
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
};

BN.prototype.toSM = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(opts)</span> {</span>
  <span class="hljs-keyword">var</span> endian = <span class="hljs-string">'big'</span>;
  <span class="hljs-keyword">if</span> (opts)
    endian = opts.endian;

  <span class="hljs-keyword">var</span> buf;
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.cmp(<span class="hljs-number">0</span>) == -<span class="hljs-number">1</span>) {
    buf = <span class="hljs-keyword">this</span>.neg().toBuffer();
    <span class="hljs-keyword">if</span> (buf[<span class="hljs-number">0</span>] &amp; <span class="hljs-number">0x80</span>)
      buf = Buffer.concat([<span class="hljs-keyword">new</span> Buffer([<span class="hljs-number">0x80</span>]), buf]);
    <span class="hljs-keyword">else</span>
      buf[<span class="hljs-number">0</span>] = buf[<span class="hljs-number">0</span>] | <span class="hljs-number">0x80</span>;
  } <span class="hljs-keyword">else</span> {
    buf = <span class="hljs-keyword">this</span>.toBuffer();
    <span class="hljs-keyword">if</span> (buf[<span class="hljs-number">0</span>] &amp; <span class="hljs-number">0x80</span>)
      buf = Buffer.concat([<span class="hljs-keyword">new</span> Buffer([<span class="hljs-number">0x00</span>]), buf]);
  }

  <span class="hljs-keyword">if</span> (buf.length === <span class="hljs-number">1</span> &amp; buf[<span class="hljs-number">0</span>] === <span class="hljs-number">0</span>)
    buf = <span class="hljs-keyword">new</span> Buffer([]);

  <span class="hljs-keyword">if</span> (endian == <span class="hljs-string">'little'</span>)
    buf = reversebuf(buf);

  <span class="hljs-keyword">return</span> buf;
};</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>This is analogous to the constructor for CScriptNum in bitcoind. Many ops in
bitcoind&#39;s script interpreter use CScriptNum, which is not really a proper
bignum. Instead, an error is thrown if trying to input a number bigger than
4 bytes. We copy that behavior here.</p></div></div><div class="code"><div class="wrapper">BN.prototype.fromScriptNumBuffer = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(buf, fRequireMinimal)</span> {</span>
  <span class="hljs-keyword">var</span> nMaxNumSize = <span class="hljs-number">4</span>;
  <span class="hljs-keyword">if</span> (buf.length &gt; nMaxNumSize)
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'script number overflow'</span>);
  <span class="hljs-keyword">if</span> (fRequireMinimal &amp;&amp; buf.length &gt; <span class="hljs-number">0</span>) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Check that the number is encoded with the minimum possible
number of bytes.
If the most-significant-byte - excluding the sign bit - is zero
then we&#39;re not minimal. Note how this test also rejects the
negative-zero encoding, 0x80.</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">if</span> ((buf[buf.length - <span class="hljs-number">1</span>] &amp; <span class="hljs-number">0x7f</span>) === <span class="hljs-number">0</span>) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>One exception: if there&#39;s more than one byte and the most
significant bit of the second-most-significant-byte is set
it would conflict with the sign bit. An example of this case
is +-255, which encode to 0xff00 and 0xff80 respectively.
(big-endian).</p></div></div><div class="code"><div class="wrapper">      <span class="hljs-keyword">if</span> (buf.length &lt;= <span class="hljs-number">1</span> || (buf[buf.length - <span class="hljs-number">2</span>] &amp; <span class="hljs-number">0x80</span>) === <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"non-minimally encoded script number"</span>);
      }
    }
  }
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.fromSM(buf, {endian: <span class="hljs-string">'little'</span>});
};</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>The corollary to the above, with the notable exception that we do not throw
an error if the output is larger than four bytes. (Which can happen if
performing a numerical operation that results in an overflow to more than 4
bytes).</p></div></div><div class="code"><div class="wrapper">BN.prototype.toScriptNumBuffer = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(buf)</span> {</span>
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.toSM({endian: <span class="hljs-string">'little'</span>});
};

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">decorate</span><span class="hljs-params">(name)</span> {</span>
  BN.prototype[<span class="hljs-string">'_'</span> + name] = BN.prototype[name];
  <span class="hljs-keyword">var</span> f = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(b)</span> {</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> b === <span class="hljs-string">'string'</span>)
      b = <span class="hljs-keyword">new</span> BN(b);
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> b === <span class="hljs-string">'number'</span>)
      b = <span class="hljs-keyword">new</span> BN(b.toString());
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>[<span class="hljs-string">'_'</span> + name](b);
  };
  BN.prototype[name] = f;
};

BN.prototype.eq = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(b)</span> {</span>
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.cmp(b) === <span class="hljs-number">0</span>;
};

BN.prototype.neq = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(b)</span> {</span>
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.cmp(b) !== <span class="hljs-number">0</span>;
};

BN.prototype.gt = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(b)</span> {</span>
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.cmp(b) &gt; <span class="hljs-number">0</span>;
};

BN.prototype.geq = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(b)</span> {</span>
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.cmp(b) &gt;= <span class="hljs-number">0</span>;
};

BN.prototype.lt = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(b)</span> {</span>
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.cmp(b) &lt; <span class="hljs-number">0</span>;
};

BN.prototype.leq = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(b)</span> {</span>
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.cmp(b) &lt;= <span class="hljs-number">0</span>;
};

decorate(<span class="hljs-string">'add'</span>);
decorate(<span class="hljs-string">'sub'</span>);
decorate(<span class="hljs-string">'mul'</span>);
decorate(<span class="hljs-string">'mod'</span>);
decorate(<span class="hljs-string">'div'</span>);
decorate(<span class="hljs-string">'cmp'</span>);
decorate(<span class="hljs-string">'gt'</span>);
decorate(<span class="hljs-string">'geq'</span>);
decorate(<span class="hljs-string">'lt'</span>);
decorate(<span class="hljs-string">'leq'</span>);

module.exports = BN;</div></div></div></div></body></html>