/* global describe,it */
'use strict'
let Ach = require('../lib/ach')
let should = require('chai').should()
let asink = require('asink')

describe('Ach (Aes+Cbc+Hmac)', function () {
  it('should exist', function () {
    should.exist(Ach)
  })

  describe('@encrypt', function () {
    it('should encrypt data', function () {
      let data = new Buffer([0])
      let cipherKey = new Buffer(256 / 8)
      cipherKey.fill(0x12)
      let encBuf = Ach.encrypt(data, cipherKey)
      encBuf.length.should.equal(256 / 8 + 256 / 8)
    })

    it('should encrypt this data and get a known value generated with sjcl', function () {
      let data = new Buffer('this is my test data')
      let cipherKey = new Buffer(256 / 8)
      cipherKey.fill(0x70)
      let ivBuf = new Buffer(128 / 8)
      ivBuf.fill(0x07)
      let encBuf = Ach.encrypt(data, cipherKey, ivBuf)
      let enchex = '5ca7fb171ef5001fdc26aca9ca806279200a8dd9bc3580b95d80335ed358627e07070707070707070707070707070707a1e5dd6b76089f0c055d718c9f597d22d727422cb1a28dd1a30aacb0cb008c1d'
      encBuf.toString('hex').should.equal(enchex)
    })
  })

  describe('@asyncEncrypt', function () {
    it('should encrypt data', function () {
      return asink(function * () {
        let data = new Buffer([0])
        let cipherKey = new Buffer(256 / 8)
        cipherKey.fill(0x12)
        let encBuf = yield Ach.asyncEncrypt(data, cipherKey)
        encBuf.length.should.equal(256 / 8 + 256 / 8)
      }, this)
    })

    it('should encrypt this data and get a known value generated with sjcl', function () {
      return asink(function * () {
        let data = new Buffer('this is my test data')
        let cipherKey = new Buffer(256 / 8)
        cipherKey.fill(0x70)
        let ivBuf = new Buffer(128 / 8)
        ivBuf.fill(0x07)
        let encBuf = yield Ach.asyncEncrypt(data, cipherKey, ivBuf)
        let enchex = '5ca7fb171ef5001fdc26aca9ca806279200a8dd9bc3580b95d80335ed358627e07070707070707070707070707070707a1e5dd6b76089f0c055d718c9f597d22d727422cb1a28dd1a30aacb0cb008c1d'
        encBuf.toString('hex').should.equal(enchex)
      }, this)
    })
  })

  describe('@decrypt', function () {
    it('should throw an error of data is incorrect length', function () {
      let encBuf = new Buffer('7519aff134f4fd273b41e50e6b9fac4d39b42afe6c2335551a4c06c4bdf9198d667b0dd26e935fdd5454e99ab27d8c17404199c79cb0c9d3884d2bd5bbd2b6', 'hex')
      let cipherKey = new Buffer(256 / 8)
      cipherKey.fill(0x12)
      ;(function () {
        Ach.decrypt(encBuf, cipherKey)
      }).should.throw('The encrypted data must be at least 256+128+128 bits, which is the length of the Hmac plus the iv plus the smallest encrypted data size')
    })

    it('should throw an error of data for incorrect hmac', function () {
      let encBuf = new Buffer('0019aff134f4fd273b41e50e6b9fac4d39b42afe6c2335551a4c06c4bdf9198d667b0dd26e935fdd5454e99ab27d8c17404199c79cb0c9d3884d2bd5bbd2b619', 'hex')
      let cipherKey = new Buffer(256 / 8)
      cipherKey.fill(0x12)
      ;(function () {
        Ach.decrypt(encBuf, cipherKey)
      }).should.throw('Message authentication failed - Hmacs are not equivalent')
    })

    it('should decrypt data', function () {
      let encBuf = new Buffer('7519aff134f4fd273b41e50e6b9fac4d39b42afe6c2335551a4c06c4bdf9198d667b0dd26e935fdd5454e99ab27d8c17404199c79cb0c9d3884d2bd5bbd2b619', 'hex')
      let cipherKey = new Buffer(256 / 8)
      cipherKey.fill(0x12)
      let data = Ach.decrypt(encBuf, cipherKey)
      data.toString('hex').should.equal('00')
    })

    it('should decrypt this encrypted data generated by sjcl', function () {
      let ptbuf = new Buffer('this is my test data')
      let pthex = ptbuf.toString('hex')
      let encBuf = new Buffer('5ca7fb171ef5001fdc26aca9ca806279200a8dd9bc3580b95d80335ed358627e07070707070707070707070707070707a1e5dd6b76089f0c055d718c9f597d22d727422cb1a28dd1a30aacb0cb008c1d', 'hex')
      let cipherKey = new Buffer(256 / 8)
      cipherKey.fill(0x70)
      let data = Ach.decrypt(encBuf, cipherKey)
      data.toString('hex').should.equal(pthex)
    })
  })

  describe('@asyncDecrypt', function () {
    it('should throw an error of data is incorrect length', function () {
      return asink(function * () {
        let encBuf = new Buffer('7519aff134f4fd273b41e50e6b9fac4d39b42afe6c2335551a4c06c4bdf9198d667b0dd26e935fdd5454e99ab27d8c17404199c79cb0c9d3884d2bd5bbd2b6', 'hex')
        let cipherKey = new Buffer(256 / 8)
        cipherKey.fill(0x12)
        let error
        try {
          yield Ach.asyncDecrypt(encBuf, cipherKey)
        } catch (err) {
          error = err
        }
        error.message.should.equal('The encrypted data must be at least 256+128+128 bits, which is the length of the Hmac plus the iv plus the smallest encrypted data size')
      }, this)
    })

    it('should throw an error of data for incorrect hmac', function () {
      return asink(function * () {
        let encBuf = new Buffer('0019aff134f4fd273b41e50e6b9fac4d39b42afe6c2335551a4c06c4bdf9198d667b0dd26e935fdd5454e99ab27d8c17404199c79cb0c9d3884d2bd5bbd2b619', 'hex')
        let cipherKey = new Buffer(256 / 8)
        cipherKey.fill(0x12)
        let error
        try {
          yield Ach.asyncDecrypt(encBuf, cipherKey)
        } catch (err) {
          error = err
        }
        error.message.should.equal('Message authentication failed - Hmacs are not equivalent')
      }, this)
    })

    it('should decrypt data', function () {
      return asink(function * () {
        let encBuf = new Buffer('7519aff134f4fd273b41e50e6b9fac4d39b42afe6c2335551a4c06c4bdf9198d667b0dd26e935fdd5454e99ab27d8c17404199c79cb0c9d3884d2bd5bbd2b619', 'hex')
        let cipherKey = new Buffer(256 / 8)
        cipherKey.fill(0x12)
        let data = yield Ach.asyncDecrypt(encBuf, cipherKey)
        data.toString('hex').should.equal('00')
      }, this)
    })

    it('should decrypt this encrypted data generated by sjcl', function () {
      return asink(function * () {
        let ptbuf = new Buffer('this is my test data')
        let pthex = ptbuf.toString('hex')
        let encBuf = new Buffer('5ca7fb171ef5001fdc26aca9ca806279200a8dd9bc3580b95d80335ed358627e07070707070707070707070707070707a1e5dd6b76089f0c055d718c9f597d22d727422cb1a28dd1a30aacb0cb008c1d', 'hex')
        let cipherKey = new Buffer(256 / 8)
        cipherKey.fill(0x70)
        let data = yield Ach.asyncDecrypt(encBuf, cipherKey)
        data.toString('hex').should.equal(pthex)
      }, this)
    })
  })
})
