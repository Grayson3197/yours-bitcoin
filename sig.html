<!DOCTYPE html><html lang="en"><head><title>sig</title></head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0"><meta name="groc-relative-root" content=""><meta name="groc-document-path" content="sig"><meta name="groc-project-path" content="lib/sig.js"><meta name="groc-github-url" content="https://github.com/ryanxcharles/fullnode"><link rel="stylesheet" type="text/css" media="all" href="assets/style.css"><script type="text/javascript" src="assets/behavior.js"></script><body><div id="meta"><div class="file-path"><a href="https://github.com/ryanxcharles/fullnode/blob/master/lib/sig.js">lib/sig.js</a></div></div><div id="document"><div class="segment"><div class="comments "><div class="wrapper"><h1 id="signature">Signature</h1>
<p>A signature is the thing you make when you want to sign a transaction, or
the thing you want to verify if you want to ensure that someone signed a
transaction. It has an r and s value, which are the cryptographic big
numbers that define a signature. And since this is a bitcoin library, it
also has nhashtype, which is the way to hash a transaction and is used in
the binary format of a signature when it is in a transaction. We also
support a public key recover value, i, allowing one to compute the public
key from a signature. The &quot;compressed&quot; value is also necessary to accurately
compute the public key from a signature.</p>
<p>There are a few different formats of a signature in bitcoin. One is DER, the
other is the TxFormat which is the same as DER but with the nhashtype byte
appended, and the final one is Compact, which is used by Bitcoin Signed
Message (BSM).</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">var</span> BN = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./bn'</span>);
<span class="hljs-keyword">var</span> Point = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./point'</span>);
<span class="hljs-keyword">var</span> Pubkey = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./pubkey'</span>);

<span class="hljs-keyword">var</span> Sig = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Sig</span><span class="hljs-params">(r, s, nhashtype)</span> {</span>
  <span class="hljs-keyword">if</span> (!(<span class="hljs-keyword">this</span> <span class="hljs-keyword">instanceof</span> Sig))
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Sig(r, s, nhashtype);
  <span class="hljs-keyword">if</span> (r <span class="hljs-keyword">instanceof</span> BN) {
    <span class="hljs-keyword">this</span>.set({
      r: r,
      s: s,
      nhashtype: nhashtype
    });
  }
  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (r) {
    <span class="hljs-keyword">var</span> obj = r;
    <span class="hljs-keyword">this</span>.set(obj);
  }
};

Sig.SIGHASH_ALL = <span class="hljs-number">0x00000001</span>;
Sig.SIGHASH_NONE = <span class="hljs-number">0x00000002</span>;
Sig.SIGHASH_SINGLE = <span class="hljs-number">0x00000003</span>;
Sig.SIGHASH_ANYONECANPAY = <span class="hljs-number">0x00000080</span>;

Sig.prototype.set = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(obj)</span> {</span>
  <span class="hljs-keyword">this</span>.r = obj.r || <span class="hljs-keyword">this</span>.r || <span class="hljs-literal">undefined</span>;
  <span class="hljs-keyword">this</span>.s = obj.s || <span class="hljs-keyword">this</span>.s || <span class="hljs-literal">undefined</span>;
  <span class="hljs-keyword">this</span>.nhashtype = <span class="hljs-keyword">typeof</span> obj.nhashtype !== <span class="hljs-string">'undefined'</span> ? obj.nhashtype : <span class="hljs-keyword">this</span>.nhashtype;
  <span class="hljs-keyword">this</span>.i = <span class="hljs-keyword">typeof</span> obj.i !== <span class="hljs-string">'undefined'</span> ? obj.i : <span class="hljs-keyword">this</span>.i; <span class="hljs-comment">//public key recovery parameter in range [0, 3]</span>
  <span class="hljs-keyword">this</span>.compressed = <span class="hljs-keyword">typeof</span> obj.compressed !== <span class="hljs-string">'undefined'</span> ? obj.compressed : <span class="hljs-keyword">this</span>.compressed; <span class="hljs-comment">//whether the recovered pubkey is compressed</span>
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
};</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>The format used by &quot;message&quot;</p></div></div><div class="code"><div class="wrapper">Sig.prototype.fromCompact = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(buf)</span> {</span>
  <span class="hljs-keyword">var</span> compressed = <span class="hljs-literal">true</span>;
  <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">var</span> compressed = <span class="hljs-literal">false</span>;
    i = i + <span class="hljs-number">4</span>;
  }

  <span class="hljs-keyword">var</span> i = buf.slice(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)[<span class="hljs-number">0</span>] - <span class="hljs-number">27</span> - <span class="hljs-number">4</span>; <span class="hljs-comment">//TODO: handle uncompressed pubkeys</span>

  <span class="hljs-keyword">var</span> b2 = buf.slice(<span class="hljs-number">1</span>, <span class="hljs-number">33</span>);
  <span class="hljs-keyword">var</span> b3 = buf.slice(<span class="hljs-number">33</span>, <span class="hljs-number">65</span>);

  <span class="hljs-keyword">if</span> (!(i === <span class="hljs-number">0</span> || i === <span class="hljs-number">1</span> || i === <span class="hljs-number">2</span> || i === <span class="hljs-number">3</span>))
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'i must be 0, 1, 2, or 3'</span>);
  <span class="hljs-keyword">if</span> (b2.length !== <span class="hljs-number">32</span>)
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'r must be 32 bytes'</span>);
  <span class="hljs-keyword">if</span> (b3.length !== <span class="hljs-number">32</span>)
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'s must be 32 bytes'</span>);

  <span class="hljs-keyword">this</span>.compressed = compressed;
  <span class="hljs-keyword">this</span>.i = i;
  <span class="hljs-keyword">this</span>.r = BN().fromBuffer(b2);
  <span class="hljs-keyword">this</span>.s = BN().fromBuffer(b3);

  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
};</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>The format used in a tx, except without the nhashtype at the end</p></div></div><div class="code"><div class="wrapper">Sig.prototype.fromDER = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(buf, strict)</span> {</span>
  <span class="hljs-keyword">var</span> obj = Sig.parseDER(buf, strict);
  <span class="hljs-keyword">this</span>.r = obj.r;
  <span class="hljs-keyword">this</span>.s = obj.s;

  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
};</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>The format used in a tx</p></div></div><div class="code"><div class="wrapper">Sig.prototype.fromTxFormat = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(buf)</span> {</span>
  <span class="hljs-keyword">var</span> nhashtype = buf.readUInt8(buf.length - <span class="hljs-number">1</span>);
  <span class="hljs-keyword">var</span> derbuf = buf.slice(<span class="hljs-number">0</span>, buf.length - <span class="hljs-number">1</span>);
  <span class="hljs-keyword">this</span>.fromDER(derbuf, <span class="hljs-literal">false</span>);
  <span class="hljs-keyword">this</span>.nhashtype = nhashtype;
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
};

Sig.prototype.fromString = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(str)</span> {</span>
  <span class="hljs-keyword">var</span> buf = <span class="hljs-keyword">new</span> Buffer(str, <span class="hljs-string">'hex'</span>);
  <span class="hljs-keyword">this</span>.fromDER(buf);

  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
};</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>In order to mimic the non-strict DER encoding of OpenSSL, set strict = false.</p></div></div><div class="code"><div class="wrapper">Sig.parseDER = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(buf, strict)</span> {</span>
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> strict === <span class="hljs-string">'undefined'</span>)
    strict = <span class="hljs-literal">true</span>;
    
  <span class="hljs-keyword">if</span> (!Buffer.isBuffer(buf))
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'DER formatted signature should be a buffer'</span>);

  <span class="hljs-keyword">var</span> header = buf[<span class="hljs-number">0</span>];

  <span class="hljs-keyword">if</span> (header !== <span class="hljs-number">0x30</span>)
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Header byte should be 0x30'</span>);

  <span class="hljs-keyword">var</span> length = buf[<span class="hljs-number">1</span>];
  <span class="hljs-keyword">var</span> buflength = buf.slice(<span class="hljs-number">2</span>).length;
  <span class="hljs-keyword">if</span> (strict &amp;&amp; length !== buflength)
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Length byte should length of what follows'</span>);
  <span class="hljs-keyword">else</span>
    length = length &lt; buflength ? length : buflength;

  <span class="hljs-keyword">var</span> rheader = buf[<span class="hljs-number">2</span> + <span class="hljs-number">0</span>];
  <span class="hljs-keyword">if</span> (rheader !== <span class="hljs-number">0x02</span>)
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Integer byte for r should be 0x02'</span>);

  <span class="hljs-keyword">var</span> rlength = buf[<span class="hljs-number">2</span> + <span class="hljs-number">1</span>];
  <span class="hljs-keyword">var</span> rbuf = buf.slice(<span class="hljs-number">2</span> + <span class="hljs-number">2</span>, <span class="hljs-number">2</span> + <span class="hljs-number">2</span> + rlength);
  <span class="hljs-keyword">var</span> r = BN().fromBuffer(rbuf);
  <span class="hljs-keyword">var</span> rneg = buf[<span class="hljs-number">2</span> + <span class="hljs-number">1</span> + <span class="hljs-number">1</span>] === <span class="hljs-number">0x00</span> ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>;
  <span class="hljs-keyword">if</span> (rlength !== rbuf.length)
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Length of r incorrect'</span>);

  <span class="hljs-keyword">var</span> sheader = buf[<span class="hljs-number">2</span> + <span class="hljs-number">2</span> + rlength + <span class="hljs-number">0</span>];
  <span class="hljs-keyword">if</span> (sheader !== <span class="hljs-number">0x02</span>)
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Integer byte for s should be 0x02'</span>);

  <span class="hljs-keyword">var</span> slength = buf[<span class="hljs-number">2</span> + <span class="hljs-number">2</span> + rlength + <span class="hljs-number">1</span>];
  <span class="hljs-keyword">var</span> sbuf = buf.slice(<span class="hljs-number">2</span> + <span class="hljs-number">2</span> + rlength + <span class="hljs-number">2</span>, <span class="hljs-number">2</span> + <span class="hljs-number">2</span> + rlength + <span class="hljs-number">2</span> + slength);
  <span class="hljs-keyword">var</span> s = BN().fromBuffer(sbuf);
  <span class="hljs-keyword">var</span> sneg = buf[<span class="hljs-number">2</span> + <span class="hljs-number">2</span> + rlength + <span class="hljs-number">2</span> + <span class="hljs-number">2</span>] === <span class="hljs-number">0x00</span> ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>;
  <span class="hljs-keyword">if</span> (slength !== sbuf.length)
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Length of s incorrect'</span>);

  <span class="hljs-keyword">var</span> sumlength = <span class="hljs-number">2</span> + <span class="hljs-number">2</span> + rlength + <span class="hljs-number">2</span> + slength;
  <span class="hljs-keyword">if</span> (length !== sumlength - <span class="hljs-number">2</span>)
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Length of signature incorrect'</span>);

  <span class="hljs-keyword">var</span> obj = {
    header: header,
    length: length,
    rheader: rheader,
    rlength: rlength,
    rneg: rneg,
    rbuf: rbuf,
    r: r,
    sheader: sheader,
    slength: slength,
    sneg: sneg,
    sbuf: sbuf,
    s: s
  };

  <span class="hljs-keyword">return</span> obj;
};</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>This function is translated from bitcoind&#39;s IsDERSignature and is used in
the script interpreter.  This &quot;DER&quot; format actually includes an extra byte,
the nhashtype, at the end. It is really the tx format, not DER format.</p>
<p>A canonical signature exists of: [30] [total len] [02] [len R] [R] [02] [len S] [S] [hashtype]
Where R and S are not negative (their first byte has its highest bit not set), and not
excessively padded (do not start with a 0 byte, unless an otherwise negative number follows,
in which case a single 0 byte is necessary and even required).</p>
<p>See <a href="https://bitcointalk.org/index.php?topic=8392.msg127623#msg127623">https://bitcointalk.org/index.php?topic=8392.msg127623#msg127623</a></p></div></div><div class="code"><div class="wrapper">Sig.isTxDER = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(buf)</span> {</span>
    <span class="hljs-keyword">if</span> (buf.length &lt; <span class="hljs-number">9</span>)</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p> Non-canonical signature: too short</p></div></div><div class="code"><div class="wrapper">        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">if</span> (buf.length &gt; <span class="hljs-number">73</span>)</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Non-canonical signature: too long</p></div></div><div class="code"><div class="wrapper">        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">if</span> (buf[<span class="hljs-number">0</span>] !== <span class="hljs-number">0x30</span>)</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p> Non-canonical signature: wrong type</p></div></div><div class="code"><div class="wrapper">        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">if</span> (buf[<span class="hljs-number">1</span>] !== buf.length - <span class="hljs-number">3</span>)</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p> Non-canonical signature: wrong length marker</p></div></div><div class="code"><div class="wrapper">        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">var</span> nLenR = buf[<span class="hljs-number">3</span>];
    <span class="hljs-keyword">if</span> (<span class="hljs-number">5</span> + nLenR &gt;= buf.length)</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p> Non-canonical signature: S length misplaced</p></div></div><div class="code"><div class="wrapper">        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">var</span> nLenS = buf[<span class="hljs-number">5</span> + nLenR];
    <span class="hljs-keyword">if</span> ((nLenR + nLenS + <span class="hljs-number">7</span>) !== buf.length)</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p> Non-canonical signature: R+S length mismatch</p></div></div><div class="code"><div class="wrapper">        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;

    <span class="hljs-keyword">var</span> R = buf.slice(<span class="hljs-number">4</span>);
    <span class="hljs-keyword">if</span> (buf[<span class="hljs-number">4</span> - <span class="hljs-number">2</span>] !== <span class="hljs-number">0x02</span>)</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p> Non-canonical signature: R value type mismatch</p></div></div><div class="code"><div class="wrapper">        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">if</span> (nLenR === <span class="hljs-number">0</span>)</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p> Non-canonical signature: R length is zero</p></div></div><div class="code"><div class="wrapper">        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">if</span> (R[<span class="hljs-number">0</span>] &amp; <span class="hljs-number">0x80</span>)</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p> Non-canonical signature: R value negative</p></div></div><div class="code"><div class="wrapper">        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">if</span> (nLenR &gt; <span class="hljs-number">1</span> &amp;&amp; (R[<span class="hljs-number">0</span>] === <span class="hljs-number">0x00</span>) &amp;&amp; !(R[<span class="hljs-number">1</span>] &amp; <span class="hljs-number">0x80</span>))</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p> Non-canonical signature: R value excessively padded</p></div></div><div class="code"><div class="wrapper">        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;

    <span class="hljs-keyword">var</span> S = buf.slice(<span class="hljs-number">6</span> + nLenR);
    <span class="hljs-keyword">if</span> (buf[<span class="hljs-number">6</span> + nLenR - <span class="hljs-number">2</span>] !== <span class="hljs-number">0x02</span>)</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p> Non-canonical signature: S value type mismatch</p></div></div><div class="code"><div class="wrapper">        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">if</span> (nLenS === <span class="hljs-number">0</span>)</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p> Non-canonical signature: S length is zero</p></div></div><div class="code"><div class="wrapper">        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">if</span> (S[<span class="hljs-number">0</span>] &amp; <span class="hljs-number">0x80</span>)</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p> Non-canonical signature: S value negative</p></div></div><div class="code"><div class="wrapper">        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">if</span> (nLenS &gt; <span class="hljs-number">1</span> &amp;&amp; (S[<span class="hljs-number">0</span>] === <span class="hljs-number">0x00</span>) &amp;&amp; !(S[<span class="hljs-number">1</span>] &amp; <span class="hljs-number">0x80</span>))</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p> Non-canonical signature: S value excessively padded</p></div></div><div class="code"><div class="wrapper">        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Compares to bitcoind&#39;s IsLowDERSignature
See also ECDSA signature algorithm which enforces this.
See also BIP 62, &quot;low S values in signatures&quot;</p></div></div><div class="code"><div class="wrapper">Sig.prototype.hasLowS = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.s.lt(<span class="hljs-number">1</span>) || <span class="hljs-keyword">this</span>.s.gt(BN().fromBuffer(<span class="hljs-keyword">new</span> Buffer(<span class="hljs-string">'7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0'</span>, <span class="hljs-string">'hex'</span>))))
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
};</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Ensures the nhashtype is exactly equal to one of the standard options or combinations thereof.
Translated from bitcoind&#39;s IsDefinedHashtypeSignature</p></div></div><div class="code"><div class="wrapper">Sig.prototype.hasDefinedHashtype = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.nhashtype &lt; Sig.SIGHASH_ALL || <span class="hljs-keyword">this</span>.nhashtype &gt; Sig.SIGHASH_SINGLE)
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
}

Sig.prototype.toCompact = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(i, compressed)</span> {</span>
  i = <span class="hljs-keyword">typeof</span> i === <span class="hljs-string">'number'</span> ? i : <span class="hljs-keyword">this</span>.i;
  compressed = <span class="hljs-keyword">typeof</span> compressed === <span class="hljs-string">'boolean'</span> ? compressed : <span class="hljs-keyword">this</span>.compressed;

  <span class="hljs-keyword">if</span> (!(i === <span class="hljs-number">0</span> || i === <span class="hljs-number">1</span> || i === <span class="hljs-number">2</span> || i === <span class="hljs-number">3</span>))
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'i must be equal to 0, 1, 2, or 3'</span>);
  
  <span class="hljs-keyword">var</span> val = i + <span class="hljs-number">27</span> + <span class="hljs-number">4</span>;
  <span class="hljs-keyword">if</span> (compressed === <span class="hljs-literal">false</span>)
    val = val - <span class="hljs-number">4</span>;
  <span class="hljs-keyword">var</span> b1 = <span class="hljs-keyword">new</span> Buffer([val]);
  <span class="hljs-keyword">var</span> b2 = <span class="hljs-keyword">this</span>.r.toBuffer({size: <span class="hljs-number">32</span>});
  <span class="hljs-keyword">var</span> b3 = <span class="hljs-keyword">this</span>.s.toBuffer({size: <span class="hljs-number">32</span>});
  <span class="hljs-keyword">return</span> Buffer.concat([b1, b2, b3]);
};

Sig.prototype.toDER = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
  <span class="hljs-keyword">var</span> rnbuf = <span class="hljs-keyword">this</span>.r.toBuffer();
  <span class="hljs-keyword">var</span> snbuf = <span class="hljs-keyword">this</span>.s.toBuffer();

  <span class="hljs-keyword">var</span> rneg = rnbuf[<span class="hljs-number">0</span>] &amp; <span class="hljs-number">0x80</span> ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>;
  <span class="hljs-keyword">var</span> sneg = snbuf[<span class="hljs-number">0</span>] &amp; <span class="hljs-number">0x80</span> ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>;

  <span class="hljs-keyword">var</span> rbuf = rneg ? Buffer.concat([<span class="hljs-keyword">new</span> Buffer([<span class="hljs-number">0x00</span>]), rnbuf]) : rnbuf;
  <span class="hljs-keyword">var</span> sbuf = sneg ? Buffer.concat([<span class="hljs-keyword">new</span> Buffer([<span class="hljs-number">0x00</span>]), snbuf]) : snbuf;

  <span class="hljs-keyword">var</span> length = <span class="hljs-number">2</span> + rbuf.length + <span class="hljs-number">2</span> + sbuf.length;
  <span class="hljs-keyword">var</span> rlength = rbuf.length;
  <span class="hljs-keyword">var</span> slength = sbuf.length;
  <span class="hljs-keyword">var</span> rheader = <span class="hljs-number">0x02</span>;
  <span class="hljs-keyword">var</span> sheader = <span class="hljs-number">0x02</span>;
  <span class="hljs-keyword">var</span> header = <span class="hljs-number">0x30</span>;

  <span class="hljs-keyword">var</span> der = Buffer.concat([<span class="hljs-keyword">new</span> Buffer([header, length, rheader, rlength]), rbuf, <span class="hljs-keyword">new</span> Buffer([sheader, slength]), sbuf]);
  <span class="hljs-keyword">return</span> der;
};

Sig.prototype.toTxFormat = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
  <span class="hljs-keyword">var</span> derbuf = <span class="hljs-keyword">this</span>.toDER();
  <span class="hljs-keyword">var</span> buf = <span class="hljs-keyword">new</span> Buffer(<span class="hljs-number">1</span>);
  buf.writeUInt8(<span class="hljs-keyword">this</span>.nhashtype, <span class="hljs-number">0</span>);
  <span class="hljs-keyword">return</span> Buffer.concat([derbuf, buf]);
};

Sig.prototype.toString = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
  <span class="hljs-keyword">var</span> buf = <span class="hljs-keyword">this</span>.toDER();
  <span class="hljs-keyword">return</span> buf.toString(<span class="hljs-string">'hex'</span>);
};

module.exports = Sig;</div></div></div></div></body></html>